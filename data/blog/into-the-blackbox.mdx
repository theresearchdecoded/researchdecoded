---
title: 'Functional Encryption 101: Into the Black Box'
date: '2025-09-03'
tags: ['functional encryption', 'cryptography', 'cybersecurity']
draft: false
summary: "A deep dive into functional encryption through the black box lens, explaining how it enables secure computations on encrypted data."
---

Functional encryption can often feel like stepping into a dense forest of symbols, equations and abstract definitions. When I first started going through the paper, “Functional Encryption: Definitions and Challenges” by Dan Boneh, Amit Sahai and Brent Waters, I felt like it was in a language that was just beyond my reach. If you have ever felt that way, this post is for you. 

This blog is a guided tour where we will walk through the paper together, unpacking the notations, highlighting the big ideas and delving deeper where things get tricky. Whether you are new to functional encryption or just need a quick refresher, you are in the right place. 
Let’s get started!

## Introduction into the Formal Language and Syntax Used
In the last post, we covered the basics of Functional Encryption. If you are new, start [here](./functional-encryption-101).

Section 1 of the paper outlines the history and motivation, which I recommend skimming for context. Here, we’ll dive into the formal language and syntax, breaking down the notation and definitions to make them easier to follow.

A functional encryption scheme is governed by four core algorithms:

1. **Setup**: It generates the public key (aka public parameters, pp) and the master key (mk). As we know, the public parameters are available to everyone, while the master key is kept secret by the trusted party.
2. **KeyGen (Key Generation)**: It uses the master key to generate the secret key (sk) tied to a particular function. This is the reason functional encryption works, i.e. being able to exact only a function of the data without decrypting the data itself.
3. **Enc (Encryption)**: It encrypts the data with the public parameters, to produce the ciphertext.
4. **Dec (Decryption)**: It uses the secret key on the ciphertext to produce the function of the data (y).

These are some of the terms often used in the definitions:

1. **Key Space (K)**: It is the set of all valid keys for a particular scheme.
2. **Plaintext Space (X)**: It is the set of all valid plaintext values for a particular scheme.
3. **Security parameter (λ)**: It controls how hard the scheme is to break. It is usually denoted by 1<sup>λ</sup>, which basically means the maximum length is 1<sup>λ</sup>. This is done to avoid the confusion that λ itself is the maximum length.
4. **Deterministic Turing Machine**: It is a theoretical computational model that is predictable. When given a particular input, it will always produce the same output in the same number of steps. When a scheme is represented by a deterministic Turing machine, it is said to be precise and well-defined. We won’t be covering Turing machines here as it is a vast topic that would need its own post.
5. **Probabilistic Polynomial Time (PPT) Algorithm**: This means the algorithms are both efficient and secure. Probabilistic means that they use randomness to make decisions. For example, flipping a coin to make a decision. Polynomial time means that even if the input size increases, the algorithm will still be able to complete in a reasonable amount of time (not infinitely running).
6. **Empty key ($\epsilon$)**: It is a special non-existent key, used to denote analyse what information about the plaintext the ciphertext leaks.
 
Now that we have a basic grasp of the language and notation, let’s dive into the key ideas introduced in the paper.

## Formal Definitions

### Definition 1:

A functionality F defined over (K, X) is a function $F : K \times X \to \{0, 1\}$ described as a (deterministic) Turing Machine. The set K is called the key space and the set X is called the plaintext space. We require that the key space K contain a special key called the empty key denoted $\epsilon$.

### Definition 2:

A functional encryption scheme (FE) for a functionality F defined over (K, X) is a tuple of four PPT algorithms (setup, keygen, enc, dec) satisfying the following correctness condition for all k &isin; K and x &isin; X:
1. **Generate a public and master secret key pair:** (pp, mk) $\leftarrow$ setup(1<sup>λ</sup>) 
2. **Generate secret key for k:** sk $\leftarrow$ keygen(mk, k) 
3. **Encrypt message x:** c $\leftarrow$ enc(pp, x) 
4. **Use sk to compute F(k, x) from c:** y $\leftarrow$ dec(sk, c) 
then we require that y = F(k, x) with probability 1.

If we now apply this to public key encryption (which we discussed in the last blog), 
Let K := {1, $\epsilon$} and consider the following functionality F defined over (K, X) for some plaintext space X: 
$$
F(k,x) :=
\begin{cases}
  x, & \text{if } k = 1 \\
  \text{len}(x), & \text{if } k = \epsilon
\end{cases}
$$

As we know, there is no logic of functions in the general public key encryption scheme. So, we are just considering two cases, k = 1 when the message gets decrypted and k = $\epsilon$, where only length of the decrypted message is revealed, nothing more. 
The last part in this section speaks about parameterisation. While we treated K and X as fixed spaces, they often depend on additional information from the Setup algorithm. For example, in RSA, Setup returns a modulus N, and the keys and plaintexts are defined over $Z_N$ (Note: $Z_N$ means a set of all integers that can be produced by modulo N). So, Setup doesn't just create keys. It also defines the environment they operate in.

## Classes of Functional Encryption

Now that we understand the building blocks, it’s time to zoom out. Functional Encryption isn’t a single scheme. Depending on what kind of functions the keys can compute, FE branches into different classes.

### Predicate Encryption

Predicate encryption is a major class of FE where the function is a yes/no question (a **predicate**). The plaintext is a pair, `(ind, m)` $\in$ `$I \times M$`, where `ind` is a descriptive label (the index) and `m` is the message. The secret key is tied to a predicate `P`.

-   If `P(ind) = 1` (the predicate is true for the index), decryption succeeds and reveals `m`.
-   If `P(ind) = 0` (the predicate is false), decryption fails and reveals nothing about `m`.

A common variation is **Predicate Encryption with Public Index**, where `ind` is revealed publicly. This is a trade-off: hiding the index is computationally expensive, so revealing it is acceptable in scenarios like searching encrypted data where efficiency is paramount.

Depending on the predicate, this class is divided into further sub-classes:

#### Identity-Based Encryption (IBE)

The predicate is a simple equality test. The index `ind` is an identity (e.g., an email address), and a key works only if it was generated for that exact identity. **Anonymous IBE** is a variant where the index is kept private.

#### Attribute-Based Encryption (ABE)

Here, the predicate is a complex access policy based on attributes.

* **Key-Policy ABE (KP-ABE)**: The ciphertext is tagged with attributes (e.g., `{'role': 'doctor', 'dept': 'cardiology'}`). The secret key contains an access policy (e.g., `'doctor' AND 'cardiology'`). The key works only if the ciphertext's attributes satisfy the policy.
* **Ciphertext-Policy ABE (CP-ABE)**: The reverse of KP-ABE. The ciphertext is encrypted with a policy, and the secret key contains attributes.

> **How is this secure?** The security relies on the trusted **Private Key Generator (PKG)**. It will only issue a secret key containing attributes that a user legitimately possesses. You can't forge attributes to get a key you aren't entitled to.

#### Hidden Vector Encryption (HVE)

The index is a vector of attributes, and the secret key checks for a specific pattern in that vector (wildcards are allowed). This enables fine-grained searches, like conjunctive queries, without revealing the attribute values.

#### Inner Product Encryption (IPE)

This is a powerful, general form of predicate encryption. The ciphertext is associated with a vector `x`, and the secret key with a vector `y`. Decryption succeeds only if the **inner product** of these vectors is zero (`$x \cdot y = 0$`).

This simple condition can express complex policies. To ensure the math works cleanly, these schemes are defined over a **finite field** (`$F_p$`), where `p` is a prime number. In a field, every non-zero element has a multiplicative inverse, which makes the mathematics both elegant and powerful.

---

## Conclusion

Through this blog, we moved beyond a simple view and uncovered the bigger picture of functional encryption and its subclasses. What began as a small idea has now taken shape into a clear, well-defined concept.

If this post felt denser than the last one, that’s completely natural—you're encountering a lot of notation and theory for the first time. I hope that as we went along, the pieces started clicking into place.

And remember, this isn’t the finish line. The real question still lingers: are these encryption schemes truly secure? That’s the mystery we’ll unravel next in our deep dive into security definitions.